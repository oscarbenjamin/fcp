<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>EMAT10006 - Further Computer Programming - </title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
  <body>
    <div id="header">
        EMAT10006 - Further Computer Programming
    </div>
    <div id="TOC">
      <ul><li><a href="index.html">Site Index</a></li></ul>
<ul>
<li><a href="#arrays-in-c">Arrays in C</a><ul>
<li><a href="#a-simple-array-program">A simple array program</a></li>
<li><a href="#less-simple-array-program">Less simple array program</a></li>
<li><a href="#exercise---reverse-an-array">Exercise - reverse an array</a></li>
<li><a href="#exercise---sieve-of-eratosphenes">Exercise - sieve of Eratosphenes</a></li>
</ul></li>
</ul>
    </div>
    <div id="main">
<h1 id="arrays-in-c"><a href="#TOC">Arrays in C</a></h1>
<p>Arrays in C are the basic way to collect objects together in a single variable. Python has a wealth of of <em>container</em> types: <code>list</code>, <code>tuple</code>, <code>dict</code> etc. In C we only have two types of collection: <em>arrays</em> and <em>structs</em>. Structs are for grouping together a fixed number of objects of possibly different types. Arrays are for grouping together a variable number of objects of the same type.</p>
<h2 id="a-simple-array-program"><a href="#TOC">A simple array program</a></h2>
<p>Let's look at a simple program that uses an array:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="co">/* array.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> primes[<span class="dv">10</span>] = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>,
                    <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">23</span>, <span class="dv">29</span>};

  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++)
  {
    printf(<span class="st">&quot;%d is prime</span><span class="ch">\n</span><span class="st">&quot;</span>, primes[i]);
  }

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>When we run this we get</p>
<pre><code>$ make
gcc -std=c99 -Wall array.c -o array.exe
$ ./array.exe
2 is prime
3 is prime
5 is prime
7 is prime
11 is prime
13 is prime
17 is prime
19 is prime
23 is prime
29 is prime</code></pre>
<p>So let's break down the program above. Firstly we have a variable called <code>primes</code> which is declared as <code>int primes[10]</code>. This means that it is an array of 10 <code>int</code>s. Since each <code>int</code> needs 4 bytes the array needs 40 bytes in total. The compiler will allocate a contiguous block of 40 bytes in memory for this array. When I say that the block is <em>continguous</em> I mean that the 40 bytes are all &quot;next to&quot; each other. All bytes in memory are numbered with non-negative integers. This block of bytes would go from e.g. byte number 256 through to byte number 295.</p>
<p>So we've looked at the array <em>declaration</em>. We can <em>initialise</em> an array using an expression with curly brackets and items separated by commas e.g. <code>{2, 3, 5, ...}</code>. This means that within the block of 40 bytes the first 4 bytes will store the number 2 (in signed 4-byte integer format). The second 4 bytes will store the number 3 etc.</p>
<p>We can access the elements of the array using subscript notation (square bracketes) just as we would for a list in Python. So to get the 3rd element of the array we would use <code>primes[2]</code>. Note that just like in Python array indices count from zero so the 1st element is <code>primes[0]</code> and if the array has length 10 then the last element is <code>primes[9]</code>.</p>
<h2 id="less-simple-array-program"><a href="#TOC">Less simple array program</a></h2>
<p>Now let's look at a slightly more advanced program:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="co">/* array2.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> print_array(<span class="dt">int</span> numbers[<span class="dv">5</span>]);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> primes[<span class="dv">5</span>] = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>};

  printf(<span class="st">&quot;Before: &quot;</span>);
  print_array(primes);

  printf(<span class="st">&quot;Setting primes[3] to -1</span><span class="ch">\n</span><span class="st">&quot;</span>);
  primes[<span class="dv">3</span>] = -<span class="dv">1</span>;

  printf(<span class="st">&quot;After: &quot;</span>);
  print_array(primes);

  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/* Print as C syntax array */</span>
<span class="dt">void</span> print_array(<span class="dt">int</span> numbers[<span class="dv">5</span>])
{
  printf(<span class="st">&quot;{%d&quot;</span>, numbers[<span class="dv">0</span>]);
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>; i&lt;<span class="dv">5</span>; i++)
  {
    printf(<span class="st">&quot;, %d&quot;</span>, numbers[i]);
  }
  printf(<span class="st">&quot;}</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre>
<p>And running this gives</p>
<pre><code>$ make
gcc -std=c99 -Wall array2.c -o array2.exe
$ ./array2.exe
Before: {2, 3, 5, 7, 11}
Setting primes[3] to -1
After: {2, 3, 5, -1, 11}</code></pre>
<p>This last program brings up a few new things to notice. Firstly in order to print an array we actually need to make our own <code>print_array</code> function. Unlike in Python there is no special support for printing anything other than elementary types in C. So we've defined a function that takes an array <code>int numbers[5]</code>. We can declare the argument to the function to be an array of a particular size e.g. 5 in this case. The function that we have used is declared as having <code>void</code> return type which is to say that it does not return anything. Also we can modify the 4th element of the array with the statement <code>primes[3] = -1</code> which sets that element to <code>-1</code>.</p>
<p>One thing to note here is that although we've defined the array to be of type <code>int[5]</code> the size of the array is ignored by the compiler when we pass the array into a function. So if you change the size of the array to 4 in the above e.g. <code>int primes[4] = {2, 3, 5, 7}</code> then you get:</p>
<pre><code>$ make array2.exe
gcc -std=c99 -Wall array2.c -o array2.exe
$ ./array2.exe
Before: {2, 3, 5, 7, 0}
Setting primes[3] to -1
After: {2, 3, 5, -1, 0}</code></pre>
<p>So the compiler didn't warn us that we were passing an array of type <code>int[4]</code> into a function that expects an array of type <code>int[5]</code>. Also if primes is an array of size 4 then how has the <code>print_array</code> function printed a 5th element? The answer is that it has simply printed whatever is in the computer's memory <em>after</em> the block which is reserved for the array. It's just chance that we happen to get zero in this case. So how do we deal with this?</p>
<p>The problem is that in C an array really is just a block of memory. When we pass the array into the function really all that happens is that the number representing the start of that block of memory is passed into the function. Within the function <code>numbers</code> refers to the same block of memory as <code>primes</code>. When we ask for e.g. <code>numbers[3]</code> we get the <code>int</code> value of the 4 bytes beginning 12 (\(=3\times 4\)) bytes from the start of that block.</p>
<p>So in C when we pass an array into a function there's no way for the code inside the function to know how big the array is. The solution is to pass in the size of the array as a separate input to the function.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="co">/* array3.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> print_array(<span class="dt">int</span> numbers[], <span class="dt">int</span> size);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> primes[] = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>,
                  <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">23</span>, <span class="dv">29</span>};

  print_array(primes, <span class="dv">10</span>);

  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/* Print as C syntax array */</span>
<span class="dt">void</span> print_array(<span class="dt">int</span> numbers[], <span class="dt">int</span> size)
{
  printf(<span class="st">&quot;{&quot;</span>);
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;size; i++)
  {
    <span class="kw">if</span>(i)
    {
      printf(<span class="st">&quot;, &quot;</span>);
    }
    printf(<span class="st">&quot;%d&quot;</span>, numbers[i]);
  }
  printf(<span class="st">&quot;}</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre>
<p>Again there's a few things to notice here. One is that we can declare an array to have type <code>int[]</code> without specifying the size. This only works for an array declaration which also initialises the array: the compiler will calculate the size by looking at the value used to initialise the array (a sequence of 10 numbers in this case). Another thing to notice is that since the size of the array is irrelevant when passing it into a function we can declare the type of the argument to <code>print_array</code> to be of type <code>int[]</code>.</p>
<p>We now have a <code>print_array</code> function that can work for an array of any size. However we will always need to remember to pass in the correct size when calling the function. This is generally what happens when working with arrays in C.</p>
<h2 id="exercise---reverse-an-array"><a href="#TOC">Exercise - reverse an array</a></h2>
<p>Write a function that can reverse the elements of an array. In Python this is easily done with e.g. <code>reversed(mylist)</code> or <code>mylist[::-1]</code> but in C this is a little less easy. The main problem is that we don't have any way to create an array inside a function and then <em>return</em> that to the caller. A common solution in C is to modify the array that is passed in as an argument to a function. This is known as modifying the input array <em>in-place</em>. Write a function called <code>reverse_inplace</code> that can be used in this way e.g.</p>
<pre class="sourceCode C"><code class="sourceCode c">  <span class="dt">int</span> numbers[<span class="dv">10</span>] = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>,
                     <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>};

  <span class="co">// Prints out {1, 2, ...}</span>
  print_array(numbers, <span class="dv">10</span>);

  <span class="co">// This is the function you need to write:</span>
  reverse_inplace(numbers, <span class="dv">10</span>);

  <span class="co">// Prints out {10, 9, ...}</span>
  print_array(numbers, <span class="dv">10</span>);</code></pre>
<p>Hint: Reversing the array swaps opposite elements, so e.g. the first element swaps with the last, the second first with the second last etc.</p>
<h2 id="exercise---sieve-of-eratosphenes"><a href="#TOC">Exercise - sieve of Eratosphenes</a></h2>
<p>The sieve of Eratosphenes is a way of efficiently computing all of the prime numbers less than some maximum number. For example suppose that we want to find all prime numbers less than 30. We begin by writing out a table of all of the numbers from 1 to 30:</p>
<pre><code>01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30</code></pre>
<p>Now 1 is not prime so we cross that out (we'll set it to -)</p>
<pre><code>-- 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30</code></pre>
<p>The first non-blank character is 2 so now we cross out all multiples of 2 except 2 itself:</p>
<pre><code>-- 02 03 -- 05 -- 07 -- 09 --
11 -- 13 -- 15 -- 17 -- 19 --
21 -- 23 -- 25 -- 27 -- 29 --</code></pre>
<p>The trick is that removing all multiples of 2 just means looping through the array in steps of 2 elements at a time. Moving on from 2 we find that the next non-blank element in the array is 3. This means that 3 is prime and now we will remove all multiples of 3:</p>
<pre><code>-- 02 03 -- 05 -- 07 -- -- --
11 -- 13 -- -- -- 17 -- 19 --
-- -- 23 -- 25 -- -- -- 29 --</code></pre>
<p>Next prime number is 5 so remove all multiples of 5:</p>
<pre><code>-- 02 03 -- 05 -- 07 -- -- --
11 -- 13 -- -- -- 17 -- 19 --
-- -- 23 -- -- -- -- -- 29 --</code></pre>
<p>Now \(6^2\) is bigger than \(30\) which means that the sieve is complete. We have now filtered out all of the prime numbers from the set of all numbers from 1 to 30.</p>
<p>Your exercise is to make a program that can use this method to find all the prime numbers from e.g. 1 to 100.</p>
<hr />
<p>Next section: <a href="strings.html">Strings</a></p>
    </div>
  </body>
</html>
