<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>EMAT10006 - Further Computer Programming - </title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
  <body>
    <div id="header">
        EMAT10006 - Further Computer Programming
    </div>
    <div id="TOC">
      <ul><li><a href="index.html">Site Index</a></li></ul>
<ul>
<li><a href="#pointers">Pointers</a><ul>
<li><a href="#exercise">Exercise</a></li>
<li><a href="#why-pointers">Why pointers?</a></li>
<li><a href="#modifying-input-arguments">Modifying input arguments</a></li>
<li><a href="#sscanf-revisited"><code>sscanf</code> revisited</a></li>
<li><a href="#pointers-and-arrays">Pointers and arrays</a></li>
</ul></li>
</ul>
    </div>
    <div id="main">
<h1 id="pointers">Pointers</h1>
<p>Pointers are a fundamental concept in C and are one of the things that don't appear in higher level languages. They are also difficult to get right and a common source of frustration for new programmers.</p>
<p>So what is a pointer? The memory (RAM) in your computer consists of a number of byte slots each of which can store one byte. My computer has 8GiB of memory which means that the number of byte slots is <span class="math">\(8\times 1024\times 1024\times 1024 = 8589934592\)</span>. Each byte slot has an integer number starting from 0.</p>
<p>Suppose we have a variable <code>x</code> of type <code>int</code> which needs 4 bytes. If the variable is stored at memory location 256 then it uses the byte slots numbered 256, 257, 258, and 259. We say that the <em>address</em> of <code>x</code> is 256. The terms &quot;memory location&quot; and &quot;address&quot; are equivalent and simply refer to the integer number of the first byte slot used to store a variable.</p>
<p>A pointer in C is an integer variable that stores the address of another variable. We say that the pointer &quot;points to&quot; the variable whose address is stores. If a pointer <code>px</code> points to a variable <code>x</code> then we can use <code>px</code> as a way to access <code>x</code> indirectly. This means that we can read or modify the value of the variable <code>x</code> through <code>px</code>. Since <code>px</code> itself is a variable we can change its value by making it point to another variable. We do this by storing the address of a different variable in <code>px</code>.</p>
<p>Here's an example from the slides:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* pointers.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> a = <span class="dv">1</span>;
  <span class="dt">int</span> b = <span class="dv">2</span>;
  <span class="dt">int</span> *pointer;
  printf(<span class="st">&quot;1: a = %d   b = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a, b);
  pointer = &amp;a;
  printf(<span class="st">&quot;2: *pointer = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *pointer);
  a = <span class="dv">3</span>;
  printf(<span class="st">&quot;3: *pointer = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *pointer);
  *pointer = <span class="dv">123</span>;
  printf(<span class="st">&quot;4: a = %d   b = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a, b);
  pointer = &amp;b;
  printf(<span class="st">&quot;5: *pointer = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *pointer);
  *pointer = -<span class="dv">1</span>;
  printf(<span class="st">&quot;6: a = %d   b = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a, b);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>And here's the output:</p>
<pre><code>$ ./pointers.exe
1: a = 1   b = 2
2: *pointer = 1
3: *pointer = 3
4: a = 123   b = 2
5: *pointer = 2
6: a = 123   b = -1</code></pre>
<p>So let's try to pull this apart. Firstly the statement <code>int *pointer</code> declares a variable with name <code>pointer</code> and type <code>int*</code>. The type <code>int*</code> is read as &quot;pointer to int&quot;. It means that the <code>pointer</code> is a pointer type variable but the compiler should interpret the variable it points to as being of type <code>int</code>.</p>
<p>The line <code>pointer = &amp;a</code> initialises the pointer with the memory address of the variable <code>a</code> which is of type <code>int</code>. If <code>a</code> was of a different type e.g. <code>char</code> then the compiler would complain since <code>pointer</code> has type <code>int*</code> an should point to a variable of type <code>int</code>. The operator <code>&amp;</code> used in this way is called the <em>address of</em> operator. We can use it on any variable and gives us the integer number of the first byte slot used by the variable. So this line stores that address in <code>pointer</code>.</p>
<p>The line <code>printf(&quot;2: *pointer = %d\n&quot;, *pointer);</code> uses <code>*pointer</code> as the value to print out. When we have a pointer variable - such as <code>pointer</code> in this example - writing <code>*pointer</code> means the value of the variable pointed to by pointer. The operator <code>*</code> used in this way is called the <em>dereferencing</em> operator. In a sense the dereferencing operator is the inverse of the address of operator since for any variable <code>a</code> we would have that <code>a==*(&amp;(a))</code>. Writing the operators the other way round (<code>&amp;(*(a))</code>) doesn't work unless <code>a</code> has a pointer type (non-pointers cannot be dereferenced). Note how the expression <code>&amp;a</code> implicitly means a value of type pointer to <code>int</code> if <code>a</code> has type <code>int</code>. Likewise if <code>a</code> has type <code>int*</code> then <code>*a</code> has type <code>int</code>.</p>
<p>We can use the dereferencing operator to read a variable as just described or we can use it to modify a value. The statement <code>*pointer = 123</code> does not change the value of <code>pointer</code>. Rather it changes the value of the variable pointed at by <code>pointer</code>. So we can use <code>*pointer</code> anywhere in a statement that we would use a normal variable name but the effect is to read/write the value of the variable whose address <code>pointer</code> stores rather than changing <code>pointer</code> itself. This is different from the statement <code>pointer = &amp;b</code> which causes the pointer to point at a different object and does not modify the value of the variables pointed to by the pointer.</p>
<h2 id="exercise">Exercise</h2>
<p>Study the above program carefully and ensure that you understand each line of output. Make your own program that uses pointers to modify variables and print out the value of all of the variables. Play around with this until you're sure that you understand this concept.</p>
<h2 id="why-pointers">Why pointers?</h2>
<p>Okay so we've talked about what pointers are now the question is: why would we want to use them? Let's work through a few simple programmes to see.</p>
<p>Firstly in C we can only ever return one value from a function. So let's say I want to have a function that parses a decimal string (e.g. &quot;123&quot;) and returns the corresponding integer value. Let's quickly make a function like that and a short programme to go with it:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* double.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>

<span class="dt">int</span> int_from_decimal_string(<span class="dt">char</span> decimal_string[]);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="kw">if</span>(argc == <span class="dv">2</span>)
    {
        <span class="dt">int</span> number = int_from_decimal_string(argv[<span class="dv">1</span>]);
        printf(<span class="st">&quot;2*%d = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, number, <span class="dv">2</span>*number);
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="kw">else</span>
    {
        fprintf(stderr, <span class="st">&quot;Usage:</span><span class="ch">\n</span><span class="st">./double.exe NUM</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> <span class="dv">1</span>;
    }
}

<span class="dt">int</span> int_from_decimal_string(<span class="dt">char</span> decimal_string[])
{
    <span class="co">/* Check that the string is all digits */</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; decimal_string[i] != &#39;\<span class="dv">0</span>&#39;; i++)
    {
        <span class="kw">if</span>(!isdigit(decimal_string[i]))
        {
            fprintf(stderr,
                    <span class="st">&quot;Bad decimal string </span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>,
                    decimal_string);
            <span class="kw">return</span> -<span class="dv">1</span>; <span class="co">// What should we return?</span>
        }
    }

    <span class="dt">int</span> total = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; decimal_string[i] != &#39;\<span class="dv">0</span>&#39;; i++)
    {
        total = total * <span class="dv">10</span> + (decimal_string[i] - &#39;<span class="dv">0</span>&#39;);
    }

    <span class="co">// Success</span>
    <span class="kw">return</span> total;
}</code></pre>
<p>We can run this programme like so</p>
<pre><code>$ make
gcc -std=c99 -Wall double.c -o double.exe
$ ./double.exe 123
2*123 = 246
$ ./double.exe 12
2*12 = 24</code></pre>
<p>Okay so far so good. Now what happens if we give the programme an invalid string? Let's try it out:</p>
<pre><code>$ ./double.exe asd
Bad decimal string &quot;asd&quot;
2*-1 = -2
$ ./double.exe -1
Bad decimal string &quot;-1&quot;
2*-1 = -2</code></pre>
<p>So the function <code>int_from_decimal_string</code> has a problem. When it finds an invalid decimal string it can print a message to <code>stderr</code> but it still needs to return a value. In this case it returns <code>-1</code>. So how can the calling code check that an error occurred? Well the calling code can just check for a return value of <code>-1</code>.</p>
<p>But what if <code>-1</code> is a valid return value from the function? The function doesn't check for minus signs but we could try and improve it to do so and then what integer value could we possibly return to indicate that an error occurred?</p>
<p>If we were working in Python we could raise an exception which would terminate the calling code. However in C there are no exceptions so any error has to be signalled somehow through the values a function returns. So maybe the function could return two values? One value would be the integer that results from parsing the string and the other could be a flag that indicates whether the function succeeded or not.</p>
<p>So how do we return two values from a function? There are two basic answers to this question. One is that we can return a struct. The other is that we can modify the inputs to the function using pointers. In this article we'll focus on using pointers.</p>
<h2 id="modifying-input-arguments">Modifying input arguments</h2>
<p>So how do we modify the input arguments to a function? Well let's just try it and see what happens:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* inputs.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> modify_value(<span class="dt">int</span> a);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argtv[])
{
    <span class="dt">int</span> a = <span class="dv">2</span>;
    modify_value(a);
    printf(<span class="st">&quot;main: a = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a);
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> modify_value(<span class="dt">int</span> a)
{
    a = <span class="dv">1</span>;
    printf(<span class="st">&quot;modify_value: a = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a);
}</code></pre>
<p>Okay so let's run that and see what happens:</p>
<pre><code>$ make
gcc -std=c99 -Wall inputs.c -o inputs.exe
$ ./inputs.exe 
modify_value: a = 1
main: a = 2</code></pre>
<p>Is that what you expected? We can see that <code>a</code> was set to 1 in <code>modify_value</code> but then it still printed out as 2 in <code>main</code>. Why is that? Really I'm deliberately confusing you by calling the parameter to <code>modify_value</code> the same name <code>a</code> as the variable in <code>main</code>. The programme above is roughly equivalent to</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* inputs.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> modify_value(<span class="dt">int</span> b);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="dt">int</span> a = <span class="dv">2</span>;
    modify_value(a);
    printf(<span class="st">&quot;main: a = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a);
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> modify_value(<span class="dt">int</span> b)
{
    b = <span class="dv">1</span>;
    printf(<span class="st">&quot;modify_value: b = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, b);
}</code></pre>
<p>What we can see more clearly in this example is that the variable <code>b</code> in <code>modify_value</code> is a different variable than the <code>a</code> in <code>main</code> (it doesn't matter if they have the same name or not). So what happens when we call <code>modify_value</code>? The <code>modify_value</code> function receives a <em>copy</em> of the <em>value</em> of the <code>a</code> variable. The value is copied to a new variable which is called <code>b</code> in <code>modify_value</code>. Inside the <code>modify_value</code> function we can modify that copy but it doesn't affect the variable <code>a</code> in the <code>main</code> function.</p>
<p>So how do we make a function that modifies one of its inputs if the function always receives copies of its input arguments? We can send the function a pointer. This works because a copy of a pointer still points to the same memory location. So how does that look:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* inputs.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> modify_value(<span class="dt">int</span> *pb);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="dt">int</span> a = <span class="dv">2</span>;
    modify_value(&amp;a);
    printf(<span class="st">&quot;main: a = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, a);
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> modify_value(<span class="dt">int</span> *pb)
{
    *pb = <span class="dv">1</span>;
    printf(<span class="st">&quot;modify_value: *pb = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *pb);
}</code></pre>
<p>And when we run this we see</p>
<pre><code>$ ./inputs.exe 
modify_value: *pb = 1
main: a = 1</code></pre>
<p>So there's a few points to note. Firstly we declare the argument is being of type pointer to int (i.e. <code>int*</code>). Secondly within the function we modify not <code>pb</code> but the value pointed to by <code>pb</code> using <code>*pb</code>. It is conventional that pointer variables often have a name that begins with 'p'. Also when we call <code>modify_value</code> we don't pass in <code>a</code> but rather <code>&amp;a</code> - the address of <code>a</code>. The address of <code>a</code> is <em>copied</em> to <code>pb</code> when the function is called. However the copy of the memory location still points to the same location so when we modify what it points to we are modifying the value of the variable <code>a</code> in the <code>main</code> function.</p>
<h2 id="sscanf-revisited"><code>sscanf</code> revisited</h2>
<p>Now generally modifying the input arguments to a function is considered bad practice. However there are many places in C where it is the natural way to do things and there are some particular functions that need to work this way. A good example is the <code>sscanf</code> function that we have already seen. A simple example of use is</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* double2.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="kw">if</span>(argc == <span class="dv">2</span>)
    {
        <span class="dt">int</span> number;
        <span class="dt">int</span> ret;

        ret = sscanf(argv[<span class="dv">1</span>], <span class="st">&quot;%d&quot;</span>, &amp;number);
        <span class="kw">if</span>(!ret)
        {
            fprintf(stderr,
                    <span class="st">&quot;Invalid decimal string </span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>,
                    argv[<span class="dv">1</span>]);
            <span class="kw">return</span> <span class="dv">1</span>;
        }

        printf(<span class="st">&quot;2 * %d = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, number, <span class="dv">2</span>*number);
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="kw">else</span>
    {
        fprintf(stderr, <span class="st">&quot;Usage:</span><span class="ch">\n</span><span class="st">./double.exe NUM</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> <span class="dv">1</span>;
    }
}</code></pre>
<p>And when we run this we see</p>
<pre><code>$ ./double2.exe asd
Invalid decimal string &quot;asd&quot;
$ ./double2.exe 123
2 * 123 = 246</code></pre>
<p>We're now in a position to understand what goes in with <code>sscanf</code>. Notice that we get two different values from <code>sscanf</code>. We have the value <code>ret</code> which is returned and also it sets the value of the variable <code>number</code> which is provided as input. We can now see why we actually pass the <em>memory address</em> of <code>number</code> (i.e. <code>&amp;number</code>) - with that <code>sscanf</code> can modify the value of <code>number</code>. Since <code>ret</code> is returned separately from <code>number</code> we have a way to detect if an error occurred in <code>sscanf</code> without needing to assume that any particular value of <code>number</code> represents an error.</p>
<h2 id="pointers-and-arrays">Pointers and arrays</h2>
<p>We are now in a position to understand how array access syntac works. An array in C is two things: it is a block of memory and it is a variable that refers to that block of memory. We can use the variable name to access the elements of the array using subscript notation. Really this just uses pointer arithmetic. Consider the following:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* pointerarray.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> array[] = {<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">5</span>};
  <span class="dt">int</span> *pointer = &amp;array[<span class="dv">0</span>];

  printf(<span class="st">&quot;array[2]       = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, array[<span class="dv">2</span>]);
  printf(<span class="st">&quot;*pointer       = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *pointer);
  printf(<span class="st">&quot;*(pointer + 2) = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, *(pointer + <span class="dv">2</span>));
  printf(<span class="st">&quot;pointer[2]     = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, pointer[<span class="dv">2</span>]);

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>When we run this we see</p>
<pre><code>$ ./pointerarray.exe
array[2]       = 10
*pointer       = 4
*(pointer + 2) = 10
pointer[2]     = 10</code></pre>
<p>This shows us a few things. Firstly we can set a pointer to piont to the first element of an array and then we can use the <code>pointer</code> variable to access the array with subscript notation just as we could with <code>array</code>. The line <code>int *pointer = &amp;array[0]</code> sets <code>pointer</code> to point to the first element of <code>array</code>. Afterwards both <code>pointer[2]</code> and <code>array[2]</code> refer to the same element of the array.</p>
<p>The third line printed shows us that <code>pointer[2]</code> is equivalent to <code>*(pointer + 2)</code>. In other words if <code>pointer</code> is a pointer to a memory address then <code>pointer + 2</code> points to the memory address that is two steps along in memory. In the case of our array if <code>pointer</code> points to the first element then the memory address two steps along is the third element.</p>
<p>In the last paragraph I've referred to the memory address that is two &quot;steps&quot; along rather than two <em>bytes</em> along. The reason for this is that each <code>int</code> uses 4 bytes. So actually if we think of the pointer is the integer number for a byte in memory then <code>pointer + 2</code> will be the integer number for the byte that is 8 bytes further along. The compiler knows that our pointer is a pointer to <code>int</code> and therefore knows that when we say <code>pointer + 1</code> we want to get the memory address that is 4 bytes further on from the location currently referred to by <code>pointer</code>. We can see this directly by printing out the value of the pointer in hex using the &quot;%p&quot; format code to <code>printf</code>. This prints out something like the integer number of the memory address for a pointer:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* pointerarithmetic.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  <span class="dt">int</span> x;
  <span class="dt">int</span> *px = &amp;x;

  printf(<span class="st">&quot;sizeof(int) = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)<span class="kw">sizeof</span>(<span class="dt">int</span>));
  printf(<span class="st">&quot;px   = %p</span><span class="ch">\n</span><span class="st">&quot;</span>, px);
  printf(<span class="st">&quot;px+1 = %p</span><span class="ch">\n</span><span class="st">&quot;</span>, px + <span class="dv">1</span>);

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>When we run this we get:</p>
<pre><code>$ ./pointerarithmetic.exe
sizeof(int) = 4
px   = 0x7fffa4d2917c
px+1 = 0x7fffa4d29180</code></pre>
<p>The two pointer values are printed in hexadecimal. Just looking at the end of the two pointer values we can see that only the last two digits are different: <code>px</code> ends with <span class="math">\(7c\)</span> whereas <code>px+1</code> ends with <span class="math">\(80\)</span>. The difference between these two is 4 which is the same as the size of an <code>int</code>.</p>
<hr />
<p>Next section: <a href="structs.html">structs</a></p>
    </div>
  </body>
</html>
