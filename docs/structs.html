<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>EMAT10006 - Further Computer Programming - </title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
  <body>
    <div id="header">
        EMAT10006 - Further Computer Programming
    </div>
    <div id="TOC">
      <ul><li><a href="index.html">Site Index</a></li></ul>
<ul>
<li><a href="#structs">Structs</a><ul>
<li><a href="#multiple-struct-variables">Multiple struct variables</a></li>
<li><a href="#exercise">Exercise</a></li>
<li><a href="#pointers-to-structs">Pointers to structs</a></li>
</ul></li>
</ul>
    </div>
    <div id="main">
<h1 id="structs"><a href="#TOC">Structs</a></h1>
<p>Structs in C are a way to create a composite data type out of elementary data types. This is similar to creating a <em>class</em> in languages such as Python but works in a lower-level way.</p>
<p>A simple example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* struct.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">struct</span> Vector3D
{
  <span class="dt">int</span> x;
  <span class="dt">int</span> y;
  <span class="dt">int</span> z;
} <span class="kw">typedef</span> Vec3D; <span class="co">// &lt;-- this is the name</span>

<span class="dt">int</span> norm2(Vec3D vector);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  Vec3D some_vector = {<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>};
  printf(<span class="st">&quot;some_vector has norm %d</span><span class="ch">\n</span><span class="st">&quot;</span>, norm2(some_vector));
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> norm2(Vec3D vector)
{
  <span class="kw">return</span> vector.x * vector.x
       + vector.y * vector.y
       + vector.z * vector.z;
}</code></pre>
<p>the output from this is</p>
<pre><code>$ ./struct.exe
some_vector has norm 26</code></pre>
<p>So what happened there? We use the <code>struct</code> statement to define a struct. Our struct represents a 3D vector and has two names <code>Vector3D</code> and <code>Vec3D</code>. The reason that it has two names is just a strange historical artefact of the way that C has evolved over the years. The first name can be anything for our purposes as we will only use the second name <code>Vec3D</code>.</p>
<p>In the body of the struct we list variables each having a type e.g. <code>int</code> and a name e.g. <code>x</code>. In this particular case our struct defines a 3D vector with 3 integer coordinates called <code>x</code>, <code>y</code>, and <code>z</code>. These are the members of the struct.</p>
<p>Having defined a struct <code>Vec3D</code> we can use this name just like <code>int</code> or <code>char</code> or any other data type. So we can declare a function called <code>norm2</code> which has an argument of type <code>Vec3D</code>. A variable of type <code>Vec3D</code> has members called <code>x</code>, <code>y</code> and <code>z</code>. In the definition of the function <code>norm2</code> the argument of type <code>Vec3D</code> is called <code>vector</code>. We can access e.g. the <code>x</code> member of the struct with the expression <code>vector.x</code>.</p>
<p>We can declare a variable of type <code>Vec3D</code> e.g. <code>Vec3D some_vector</code>. Since the struct has 3 members and each of those needs 4 bytes of storage space the total space needed for <code>some_vector</code> is 12 bytes (on some systems it may end up using more space because of <em>alignment</em> but I don't want to explain that here).</p>
<h2 id="multiple-struct-variables"><a href="#TOC">Multiple struct variables</a></h2>
<p>In the example above the struct doesn't seem like much of an improvement over just using 3 separate variables. One way in which structs start to become more useful is if we have many struct variables of the same type. In our example each can group together its 3 coordinates keeping them as a single object. Let's extend the above example to have two vectors and a dot product function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* dot.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">struct</span> Vector3D
{
  <span class="dt">int</span> x;
  <span class="dt">int</span> y;
  <span class="dt">int</span> z;
} <span class="kw">typedef</span> Vec3D; <span class="co">// &lt;-- this is the name</span>

<span class="dt">int</span> dot(Vec3D a, Vec3D b);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  Vec3D vec1 = {<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>};
  Vec3D vec2 = {-<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>};
  printf(<span class="st">&quot;vec1 dot vecb = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, dot(vec1, vec2));
  <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> dot(Vec3D a, Vec3D b)
{
  <span class="kw">return</span> a.x * b.x + a.y * b.y + a.z * b.z;
}</code></pre>
<p>We can even have an array of structs e.g. <code>Vec3D vectors[10]</code> and we can initialise this by combining struct initialisation syntax with array initialisation syntax:</p>
<pre class="sourceCode c"><code class="sourceCode c">   Vec3D vectors[<span class="dv">3</span>] = {{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}, {<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>}, {<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>}};</code></pre>
<h2 id="exercise"><a href="#TOC">Exercise</a></h2>
<p>Extend the above by adding a cross product function and a function to print a vector displaying it as e.g. <code>(1, 2, 3)</code>.</p>
<h2 id="pointers-to-structs"><a href="#TOC">Pointers to structs</a></h2>
<p>Just as we can have pointers to other variables we can also have pointers to structs. We declare them in much the same way but a pointer to a struct gives us a special syntax for accessing the members of the struct. A short example is</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* pstruct.c */</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">struct</span> Vector3D
{
  <span class="dt">int</span> x;
  <span class="dt">int</span> y;
  <span class="dt">int</span> z;
} <span class="kw">typedef</span> Vec3D;

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
  Vec3D vec = {<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>};

  Vec3D *pvec = &amp;vec;

  <span class="co">// These two are equivalent</span>
  printf(<span class="st">&quot;(*pvec).x = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, (*pvec).x);
  printf(<span class="st">&quot;pvec-&gt;x   = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, pvec-&gt;x);

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>When we run this we get <code>(*pvec).x = 3 pvec-&gt;x   = 3</code></p>
<p>This shows the two equivalent ways to access the member of a struct through a pointer to the struct. After <code>pvec = &amp;vec</code> we can think of <code>*pvec</code> and <code>vec</code> as equivalent. So naturally <code>vec.x</code> and <code>(*pvec).x</code> are equivalent. The brackets don't mean anything special here - they just clarify the order of the operations: we want to dereference the pointer and <em>then</em> access the <code>x</code> member of the result, rather than the other way round.</p>
<p>Since structs and pointers to structs are so common in C there is a shorthand notation for this. The two expressions <code>(*pvec).x</code> and <code>pvec-&gt;x</code> are equivalent. The arrow <code>-&gt;</code> notation is preferred though. It is not uncommon to have a struct with a member that is a pointer to another struct (and so on). In that case the reason for preferring one notation over the other is clearer:</p>
<pre class="sourceCode c"><code class="sourceCode c">pstruct1-&gt;pstruct2-&gt;x = <span class="dv">1</span>;  <span class="co">// &lt;--- preferred</span>
(*(*pstruct1).pstruct2).x = <span class="dv">1</span>;</code></pre>
<hr />
<p>Next section: <a href="fileio.html">fileio</a></p>
    </div>
  </body>
</html>
